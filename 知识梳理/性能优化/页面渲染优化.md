# 页面渲染优化

- 图像优化（格式选择，大小，雪碧图，base64）
- 加载优化（cdn，gzip，减少请求，预连接，预提取，预加载）
- 渲染优化（避免重绘和回流，语义化标签，css优化，）
- 存储优化（缓存，web storage ,redux时间，减少请求，缓存资源使用）
- 构建优化（打包优化，压缩，混淆，摇树，按需加载）
- 代码优化（高性能代码，小技巧）

浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。
在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘。

一般我会分为以下几个方面来回答，一般会引申到网络、缓存方面的问题：

server：

- 使用 cdn
- 减少不必要的数据返回
- 使用 gzip
- 缓存 （Cache-Control, pagram,etag / expires ...）

content：

- 减少 http 请求 (css sprites / inline image)
- 不同资源放在不同域下 (http1.1)
- 延迟加载 / 延迟执行(立即下载，延迟执行[before DOMContentLoaded]defer) / 预加载(preload)
  - **async**，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有 src 属性的脚本）。
  - **defer**，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发`DOMContentLoaded`事件前执行。
- 精简 HTML 结构
- 压缩资源

css:

- in head
- 较少的层级（之前被问到过是否有统计过层级多与少对性能的实质影响，实际上我是没有做过此类研究，所以知道结论而不懂过程还是欠缺的）

js:

- before
- 减少 dom 访问（在 body 内放置的 JS 代码是否可以访问到 body 标签）

webpack:

- tree shaking 去除没有使用的代码
- 提取公共包，有被问到
- 拆分模块，按需加载
- 优化图片，使用 base64 代替小图
- file name with hash (etag)
