# 算法复杂度

## 为什么需要复杂度分析

- 学习数据和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使运算效率更快，占用空间更小。那如何来计算代码执行效率呢？这里就会用到复杂度分析。
- 虽然我们可以用代码准确的计算出执行时间，但是这也会有很多局限性。
- 数据规模的不同会直接影响到测试结果。比如说同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样；如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如说如果数据规模比较小的话，测试结果可能也无法反应算法的性能。
- 测试的环境不同也会影响到测试结果。比如说同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。

所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是**复杂度分析**。

## 大 O 复杂度表示法

以一个例子开始，请估算下面代码的执行时间

```jsx
function total(n) { // 1
      var sum = 0; // 2
      for (var i = 0; i < n; i++) { // 3
        sum += i; // 4
      } //5
    } //6
```

我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)*t。

那么按照上面的分析方法，请估算下面代码的执行时间



```jsx
 function total(n) { // 1
      var sum = 0; // 2
      for (var i = 0; i < n; i++) { // 3
        for (var j = 0; j < n; j++) { // 4
          sum = sum + i + j; // 5
        }
      }
    }
```

第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n2 个的时间，那么这段代码总的执行时间为 (2n2+n+1)*t 的时间。

从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比

> T(n) = O(f(n))

在这个公式中，T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

所以上边两个函数的执行时间可以标记为 T(n) = O(2n+1) 和 T(n) = O(2n2+n+1)。这就是**大 O 时间复杂度表示法**，它不代表代码真正的执行时间，而是表示**代码随数据规模增长的变化趋势**，简称**时间复杂度**。

而且当 n 很大时，我们可以忽略常数项，只保留一个最大量级即可。所以上边的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n2)。

## 时间复杂度分析

那如何分析一段代码的时间复杂度呢，可以利用下面的几个方法

### 1.只关注循环执行次数最多的一段代码

我们在分析一段代码的时间复杂度时，我们只要关注循环次数最多的那一段代码就 ok 了。
 比如说在第一段代码中

```jsx
function total(n) { // 1
      var sum = 0; // 2
      for (var i = 0; i < n; i++) { // 3
        sum += i; // 4
      } //5
    } //6
```

只有第 3 行和第 4 行是执行次数最多的，分别执行了 n 次，那么忽略常数项，所以此段代码的时间复杂度就是 O(n)。

### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度。

比如说，看下面这段代码的时间复杂度。

```jsx
function total(n) {
      // 第一个 for 循环
      var sum1 = 0;
      for (var i = 0; i < n; i++) {
        for (var j = 0; j < n; j++) {
          sum1 = sum1 + i + j;
        }
      }
      // 第二个 for 循环
      var sum2 = 0;
      for(var i=0;i<1000;i++) {
        sum2 = sum2 + i;
      }
      // 第三个 for 循环
      var sum3 = 0;
      for (var i = 0; i < n; i++) {
        sum3 = sum3 + i;
      }
    }
```

我们先分别分析每段 for 循环的时间复杂度，再取他们中最大的量级来作为整段代码的时间复杂度。

第一段 for 循环的时间复杂度为 O(n2)。

第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。

第三段 for 循环的时间复杂度为 O(n)。

总上，取最大量级，所以整段代码的时间复杂度为 O(n2)。

### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

比如说，看下面这段代码的时间复杂度

```jsx
  function f(i) {
      var sum = 0;
      for (var j = 0; j < i; j++) {
        sum += i;
      }
      return sum;
    }
    function total(n) {
      var res = 0;
      for (var i = 0; i < n; i++) {
        res = res + f(i); // 调用 f 函数
      }
    }
```

单独看 total 函数的时间复杂度就是为 T1(n)=O(n)，但是考虑到 f 函数的时间复杂度也为 T2(n)=O(n)。
 所以整段代码的时间复杂度为 T(n) = T1(n) * T2(n) = O(n*n)=O(n2)。

## 几种常见的时间复杂度分析

只看最高量级的复杂度

![img](https:////upload-images.jianshu.io/upload_images/12520694-e0582bfd11c388a1.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

Xnip2019-01-03_16-59-22.jpg

如上图可以粗略的分为两类，**多项式量级**和**非多项式量级**。其中，**非多项式量级**只有两个：O(2n) 和 O(n!)
 对应的增长率如下图所示

![img](https:////upload-images.jianshu.io/upload_images/12520694-c3cbd4961d032d7f?imageMogr2/auto-orient/strip|imageView2/2/w/702/format/webp)

image


 当数据规模 n 增长时，**非多项式量级**的执行时间就会急剧增加，所以，**非多项式量级**的代码算法是非常低效的算法。

### 1. O(1)

O(1) 只是常量级时间复杂度表示法，并不是代码只有一行，比如说下面这段代码

```jsx
function total() {
      var sum = 0;
      for(var i=0;i<100;i++) {
        sum += i;
      }
    }
```

虽然有这么多行，即使 for 循环执行了 100 次，但是代码的执行时间不随 n 的增大而增长，所以这样的代码复杂度就为 O(1)。

### 2. O(logn)、O(nlogn)

对数阶时间复杂度的常见代码如下

```jsx
 function total1(n) {
      var sum = 0;
      var i = 1;
      while (i <= n) {
        sum += i;
        i = i * 2;
      }
    }
    function total2(n) {
      var sum = 0;
      for (var i = 1; i <= n; i = i * 2) {
        sum += i;
      }
    }
```

上面两个函数都有一个相同点，变量 i 从 1 开始取值，每循环一次乘以 2，当大于 n 时，循环结束。实际上，i 的取值就是一个等比数列，就像下面这样

> 20 21 22  ... 2k... 2x  =n;

所以只要知道 x 的值，就可以知道这两个函数的执行次数了。那由 2x = n 可以得出 x = log2n，所以这两个函数的时间复杂度为 O(log2n)。

再看下面两个函数的时间复杂度

```jsx
 function total1(n) {
      var sum = 0;
      var i = 1;
      while (i <= n) {
        sum += i;
        i = i * 3;
      }
    }
    function total2(n) {
      var sum = 0;
      for (var i = 1; i <= n; i = i * 3) {
        sum += i;
      }
    }
```

由上可以得知，这两个函数的时间复杂度为 O(log3n) 。

由于我们可以忽略常数，也可以忽略对数中的底数，所以在对数阶复杂度中，统一表示为 O(logn)；那 O(nlogn) 的含义就很明确了，时间复杂度 为O(logn) 的代码执行了 n 次。

### 3. O(m+n)、O(m*n)

再来看一段特殊的代码时间复杂度，比如说

```jsx
 function total(m,n) {
      var sum1 = 0;
      for (var i = 0; i < n; i++) {
        sum1 += i;
      }
      var sum2 = 0;
      for (var i = 0; i < m; i++) {
        sum2 += i;
      }
      return sum1 + sum2;
    }
```

因为我们无法评估 m 和 n 谁的量级比较大，所以就不能忽略掉其中一个，这个函数的复杂度是有两个数据的量级来决定的，所以此函数的时间复杂度为 O(m+n)；那么 O(m*n) 的时间复杂度类似。

## 空间复杂度分析

空间复杂度的话和时间复杂度类似推算即可。
 所谓空间复杂度就是**表示算法的存储空间和数据规模之间的关系**。

比如说分析下面代码的空间复杂度：

```jsx
function initArr(n) {
      var arr = [];
      for (var i = 0; i < n; i++) {
        arr[i] = i;
      }
    }
```

根据时间复杂度的推算，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数的空间复杂度为 O(n)。

常见的空间复杂度只有 O(1)、O(n)、O(n2)。其他的话很少会用到。

## 思考题解答

现在我们回到开始的思考题上，代码实现很简单：

```jsx
function total(n) {
      var sum = 0;
      for (var i = 1; i <= n; i++) {
        sum += i;
      }
      return sum;
    }
```

此函数的时间复杂度你现在应该很容易就能看出来了，为 O(n)。

我觉得这个时间复杂度有点高了，我想要 O(1) 的时间复杂度函数来实现这个算法，可以吗？

可以的，小数学神通高斯教会我们一招，如下

```jsx
function total(n) {
      var sum = n*(n+1)/2
      return sum;
    }
```

此函数的时间复杂度仅仅为 O(1)，在数据规模比较庞大的时候，下面的函数是不是明显比上面的函数运算效率更高呢。

## 总结

> **复杂度**也叫**渐进复杂度**，包括**时间复杂度**和**空间复杂度**，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。

学习了复杂度分析后，是不是能避免写出效率低的代码呢？来给你的代码做个分析吧。



作者：雨蒙_snow
链接：https://www.jianshu.com/p/ffbb25380904
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
